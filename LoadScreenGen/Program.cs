using System;
using System.Collections.Generic;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Threading.Tasks;
using System.IO;
using System.Text.RegularExpressions;
using LoadScreenGen.Settings;
using System.Diagnostics;

namespace LoadScreenGen {
    public class Program {

        public static string fomodTmpPath = "";

        public static string resourceDirectory = "";
        public static IPatcherState<ISkyrimMod, ISkyrimModGetter>? state = null;

        static Lazy<MainSettings> _Settings = null!;
        public static MainSettings Settings => _Settings.Value;

        public static Task<int> Main(string[] args) {
            return SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out _Settings)
                .SetTypicalOpen(GameRelease.SkyrimLE, "YourPatcher.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) {
            //Your code here!
            Program.resourceDirectory = state.InternalDataPath ?? "";
            Program.state = state;

            if(Program.resourceDirectory == "" || !Directory.Exists(Program.resourceDirectory)) {
                throw new DirectoryNotFoundException("Cannot find resource directory.");
            }

            var sse = state.GameRelease != GameRelease.SkyrimLE && state.GameRelease != GameRelease.EnderalLE;
            string templatePath;
            if(sse) {
                templatePath = Path.Combine(resourceDirectory, "TemplateSSE.nif");
            } else {
                templatePath = Path.Combine(resourceDirectory, "TemplateLE.nif");
            }
            SkyrimRelease release = sse ? SkyrimRelease.SkyrimSE : SkyrimRelease.SkyrimLE;




            if(!Settings.authorSettings.enableAuthorMode) {
                if(Directory.Exists(Settings.userSettings.sourcePath)) {
                    if(Settings.userSettings.imageResolution != 1024 && Settings.userSettings.imageResolution != 2048 && Settings.userSettings.imageResolution != 4096 && Settings.userSettings.imageResolution != 8192) {
                        throw new ArgumentException("Image resolution must be 1024, 2048, 4096 or 8192.");
                    }
                    if(Settings.userSettings.loadScreenPriority == LoadingScreenPriority.Frequency || Settings.userSettings.loadScreenPriority == LoadingScreenPriority.Mcm) {
                        if(Settings.userSettings.frequency <= 0) {
                            throw new ArgumentException("Frequency must be larger than 0.");
                        }
                        if(Settings.userSettings.frequency > 100) {
                            throw new ArgumentException("Frequency must be at most 100.");
                        }
                    }

                    var stopWatch = Stopwatch.StartNew();
                    var imageArray = TextureGen.ProcessTextures(Settings.userSettings.sourcePath, new string[] { Path.Combine(state.DataFolderPath, "textures", Settings.userSettings.defaultModFolder) }, new int[] { Settings.userSettings.imageResolution }, Settings.userSettings.includeSubDirs);
                    stopWatch.Stop();
                    Logger.LogTime("Texture generation", stopWatch.Elapsed);

                    stopWatch.Restart();
                    string meshDirectory = Path.Combine(state.DataFolderPath, "meshes", Settings.userSettings.defaultModFolder);
                    string textureDirectory = Path.Combine("textures", Settings.userSettings.defaultModFolder);
                    Directory.CreateDirectory(meshDirectory);
                    MeshGen.CreateMeshes(imageArray.ToList(), meshDirectory, textureDirectory, templatePath, Settings.userSettings.screenWidth * 1.0 / Settings.userSettings.screenHeight, Settings.userSettings.borderOption);
                    stopWatch.Stop();
                    Logger.LogTime("Mesh generation", stopWatch.Elapsed);

                    stopWatch.Restart();
                    PluginGen.CreateEsp(state.PatchMod, imageArray, Settings.userSettings.defaultModFolder, Settings.userSettings.defaultPrefix, true, Settings.userSettings.frequency, Settings.userSettings.loadScreenPriority);
                    stopWatch.Stop();
                    Logger.LogTime("Plugin generation took: ", stopWatch.Elapsed);
                } else {
                    throw new DirectoryNotFoundException("Cannot find source directory.");
                }
            } else {
                if(Directory.Exists(Settings.authorSettings.sourcePath)) {
                    if(string.IsNullOrEmpty(Settings.authorSettings.modName) || Settings.authorSettings.modName.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0) {
                        throw new ArgumentException("The mod name is not a valid file name.");
                    }
                    if(Settings.authorSettings.modVersion.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0) {
                        throw new ArgumentException("The mod version contains invalid characters. Only use characters that can be part of file names.");
                    }
                    if(string.IsNullOrEmpty(Settings.authorSettings.pluginName) || Settings.authorSettings.pluginName.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0) {
                        throw new ArgumentException("The plugin name is not a valid file name.");
                    }
                    if(!Settings.authorSettings.pluginName.EndsWith(".esp")) {
                        throw new ArgumentException("The plugin name must end with \".esp\".");
                    }
                    var validPrefix = new Regex("[a-zA-Z_][a-zA-Z\\d_]*");
                    if(validPrefix.Match(Settings.authorSettings.pluginPrefix).Value != Settings.authorSettings.pluginPrefix) {
                        throw new ArgumentException("The plugin prefix is invalid. It must not be empty and must start with a letter or an underscore. Then any number of letters, digits or underscores may follow.");
                    }
                    if(string.IsNullOrEmpty(Settings.authorSettings.modFolder) || Settings.authorSettings.modFolder.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0) {
                        throw new ArgumentException("The mod folder is not a valid file name.");
                    }

                    var stopWatch = Stopwatch.StartNew();

                    fomodTmpPath = Path.Combine(Path.GetTempPath(), "JLoadScreens");
                    Directory.CreateDirectory(fomodTmpPath);
                    Directory.Delete(fomodTmpPath, true);
                    Directory.CreateDirectory(fomodTmpPath);

                    var targetDirectory = new List<string>();
                    var imageResolution = new List<int>();

                    targetDirectory.Add(Path.Combine(Path.Combine(state.DataFolderPath, fomodTmpPath, "textures", "2K"), "textures", Settings.authorSettings.modFolder));
                    imageResolution.Add(2048);
                    if(Settings.authorSettings.resolutionSettings.fourK) {
                        targetDirectory.Add(Path.Combine(Path.Combine(state.DataFolderPath, fomodTmpPath, "textures", "4K"), "textures", Settings.authorSettings.modFolder));
                        imageResolution.Add(4096);
                    }
                    if(Settings.authorSettings.resolutionSettings.eightK) {
                        targetDirectory.Add(Path.Combine(Path.Combine(state.DataFolderPath, fomodTmpPath, "textures", "8K"), "textures", Settings.authorSettings.modFolder));
                        imageResolution.Add(8192);
                    }

                    string textureDirectory = Path.Combine("textures", Settings.authorSettings.modFolder);
                    var imageArray = TextureGen.ProcessTextures(Settings.authorSettings.sourcePath, targetDirectory.ToArray(), imageResolution.ToArray(), Settings.authorSettings.includeSubDirs);
                    stopWatch.Stop();
                    Logger.LogTime("Texture generation", stopWatch.Elapsed);

                    stopWatch.Restart();

                    HashSet<BorderOption> borderOptions = new();
                    if(Settings.authorSettings.borderSettings.includeNormal) {
                        borderOptions.Add(BorderOption.Normal);
                    }
                    if(Settings.authorSettings.borderSettings.includeCrop) {
                        borderOptions.Add(BorderOption.Crop);
                    }
                    if(Settings.authorSettings.borderSettings.includeFixedHeight) {
                        borderOptions.Add(BorderOption.FixedHeight);
                    }
                    if(Settings.authorSettings.borderSettings.includeFixedWidth) {
                        borderOptions.Add(BorderOption.FixedWidth);
                    }
                    if(Settings.authorSettings.borderSettings.includeStretch) {
                        borderOptions.Add(BorderOption.Stretch);
                    }
                    if(borderOptions.Count == 0) {
                        throw new ArgumentException("At least one border option must be enabled.");
                    }
                    if(borderOptions.Count > 1) {
                        if(!borderOptions.Contains(Settings.authorSettings.borderSettings.defaultBorderOption)) {
                            throw new ArgumentException("If there are multiple border options, the default border option must be set to one of them.");
                        }
                    }
                    HashSet<LoadingScreenPriority> loadScreenPriorities = new();
                    if(Settings.authorSettings.prioritySettings.includeStandalone) {
                        loadScreenPriorities.Add(LoadingScreenPriority.Standalone);
                    }
                    if(Settings.authorSettings.prioritySettings.includeReplacer) {
                        loadScreenPriorities.Add(LoadingScreenPriority.Replacer);
                    }
                    if(Settings.authorSettings.prioritySettings.includeFrequency) {
                        loadScreenPriorities.Add(LoadingScreenPriority.Frequency);
                    }
                    if(Settings.authorSettings.prioritySettings.includeMcm) {
                        loadScreenPriorities.Add(LoadingScreenPriority.Mcm);
                    }
                    if(Settings.authorSettings.prioritySettings.includeDebug) {
                        loadScreenPriorities.Add(LoadingScreenPriority.Debug);
                    }
                    if(loadScreenPriorities.Count == 0) {
                        throw new ArgumentException("At least one priority option must be enabled.");
                    }
                    if(loadScreenPriorities.Count > 1) {
                        if(!loadScreenPriorities.Contains(Settings.authorSettings.prioritySettings.defaultPrioritySetting)) {
                            throw new ArgumentException("If there are multiple priority options, the default priority option must be set to one of them.");
                        }
                    }
                    var outputDirectory = Settings.authorSettings.outputDirectory;
                    if(!Directory.Exists(outputDirectory)) {
                        throw new DirectoryNotFoundException("Cannot find output directory.");
                    }


                    var aspectRatios = AspectRatio.Parse(Settings.authorSettings.aspectRatios);
                    foreach(var borderOption in borderOptions) {
                        foreach(var aspectRatio in aspectRatios) {
                            var displayRatio = aspectRatio.w * 1.0 / aspectRatio.h;
                            string meshDirectory = Path.Combine(state.DataFolderPath, fomodTmpPath, "meshes");
                            meshDirectory = Path.Combine(meshDirectory, "" + aspectRatio);
                            meshDirectory = Path.Combine(meshDirectory, "" + borderOption);
                            meshDirectory = Path.Combine(meshDirectory, "meshes", Settings.authorSettings.modFolder);
                            Directory.CreateDirectory(meshDirectory);
                            MeshGen.CreateMeshes(imageArray.ToList(), meshDirectory, textureDirectory, templatePath, displayRatio, borderOption);
                        }
                    }

                    stopWatch.Stop();
                    Logger.LogTime("Mesh generation", stopWatch.Elapsed);

                    stopWatch.Restart();
                    List<int> frequencyList = new();
                    int defaultFrequency;
                    var frequencyArray = Settings.authorSettings.frequencyList.Split(",");
                    foreach(var s in frequencyArray) {
                        frequencyList.Add(int.Parse(s));
                        if(!loadScreenPriorities.Contains(LoadingScreenPriority.Frequency) && !loadScreenPriorities.Contains(LoadingScreenPriority.Mcm)) {
                            // no frequency choice
                            break;
                        }
                    }
                    defaultFrequency = frequencyList.First();
                    foreach(var loadScreenPriority in loadScreenPriorities) {
                        var newFrequencyList = new List<int>();
                        if((loadScreenPriority == LoadingScreenPriority.Frequency) || (loadScreenPriority == LoadingScreenPriority.Mcm)) {
                            newFrequencyList.AddRange(frequencyList);
                        } else {
                            newFrequencyList.Add(frequencyList.First());
                        }
                        foreach(var frequency in newFrequencyList) {
                            if(Settings.authorSettings.loadingScreenText != LoadingScreenText.Never) {
                                CreatePluginOptions(release, state.DataFolderPath, frequency, true, imageArray, loadScreenPriority);
                            }
                            if(Settings.authorSettings.loadingScreenText != LoadingScreenText.Always) {
                                CreatePluginOptions(release, state.DataFolderPath, frequency, false, imageArray, loadScreenPriority);
                            }
                        }
                    }
                    stopWatch.Stop();
                    Logger.LogTime("Plugin generation", stopWatch.Elapsed);

                    stopWatch.Restart();
                    FomodGen.CreateFomod(imageArray, aspectRatios, borderOptions, loadScreenPriorities, frequencyList, defaultFrequency, imageResolution, targetDirectory, outputDirectory);
                    //Directory.Delete(fomodTmpPath, true);
                    stopWatch.Stop();
                    Logger.LogTime("Fomod generation", stopWatch.Elapsed);
                } else {
                    throw new DirectoryNotFoundException("Cannot find source directory.");
                }
            }
        }
        public static string GetPluginName(int frequency, bool includeText, LoadingScreenPriority loadScreenPriority) {
            return "FOMOD_M" + (includeText ? "1" : "0") + "_C_" + loadScreenPriority + "_P" + frequency + "_FOMODEND_" + Settings.authorSettings.pluginName;
        }
        public static void CreatePluginOptions(SkyrimRelease release, string dataPath, int frequency, bool includeText, Image[] imageArray, LoadingScreenPriority loadScreenPriority) {
            var pluginPath = GetPluginName(frequency, includeText, loadScreenPriority);
            pluginPath = Path.Combine(fomodTmpPath, pluginPath);
            var mod = PluginGen.CreateNewEsp(pluginPath, release, dataPath);
            PluginGen.CreateEsp(mod, imageArray, Settings.authorSettings.modFolder, Settings.authorSettings.pluginPrefix, includeText, frequency, loadScreenPriority);
            PluginGen.WriteNewEsp(mod, pluginPath);
        }
    }
    public class AspectRatio {
        public int w;
        public int h;
        public AspectRatio(int w, int h) {
            this.w = w;
            this.h = h;
        }

        public override bool Equals(object? obj) {
            if(obj is AspectRatio asAspectRatio) {
                return asAspectRatio.w == w && asAspectRatio.h == h;
            }
            return false;
        }

        public static HashSet<AspectRatio> Parse(string parseString) {
            HashSet<AspectRatio> set = new();
            var singleStrings = parseString.Split(",");
            foreach(string s in singleStrings) {
                var whString = s.Split(":");
                if(whString.Length != 2) {
                    throw new ArgumentException("Could not parse Aspect Ratio string:<" + parseString + ">");
                }
                set.Add(new AspectRatio(int.Parse(whString[0]), int.Parse(whString[1])));
            }
            return set;
        }

        public override string ToString() {
            return w + "x" + h;
        }

        public override int GetHashCode() {
            return Tuple.Create(w, h).GetHashCode();
        }
    }
}
